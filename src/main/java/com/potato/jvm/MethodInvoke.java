package com.potato.jvm;

/**
 * @author dehuab
 * <p>
 * 在正常情况下，如果我们想要在同一个类中定义名字相同的方法，那么它们的参数类型必须不同。
 * 小知识：这个限制可以通过字节码工具绕开。也就是说，在编译完成之后，我们可以再向class文件中添加方法名和参数类型相同，而返回类型不同的方法。
 * 当这种包括多个方法名相同、参数类型相同，而返回类型不同的方法的类，出现在Java编译器的用户类路径上时，它是怎么确定需要调用哪个方法的呢？
 * 当前版本的Java编译器会直接选取第一个方法名以及参数类型匹配的方法，并且它会根据所选取方法的返回类型来决定可不可以通过编译，以及需不需要进行值转换等。
 * </p>
 * <p>
 * 重载方法选取的过程共分为三个阶段：
 * 1、在不考虑对基本类型自动装拆箱（auto-boxing，auto-unboxing），以及可变长参数的情况下选取重载方法；
 * 2、如果在第1个阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法；
 * 3、如果在第2个阶段中没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法。
 * 如果 Java 编译器在同一个阶段中找到了多个适配的方法，那么它会在其中选择一个最为贴切的，而决定贴切程度的一个关键就是形式参数类型的继承关系。
 * </p>
 * <p>
 * 除了同一个类中的方法，重载也可以作用于这个类所继承而来的方法。
 * 也就是说，如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型不同，那么在子类中，这两个方法同样构成了重载。
 * 那么，如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型相同，那么这两个方法之间又是什么关系呢？
 * 如果这两个方法都是静态的，那么子类中的方法隐藏了父类中的方法。
 * 如果这两个方法都不是静态的，且都不是私有的，那么子类的方法重写了父类中的方法。
 * </p>
 * <p>
 * Java 虚拟机识别方法的关键在于类名、方法名以及方法描述符（method descriptor）。
 * 方法描述符是由方法的参数类型以及返回类型所构成。
 * 在同一个类中，如果同时出现多个名字相同且描述符也相同的方法，那么Java虚拟机会在类的验证阶段报错。
 * Java虚拟机与Java语言不同，它并不限制名字与参数类型相同，但返回类型不同的方法出现在同一个类中，
 * 对于调用这些方法的字节码来说，由于字节码所附带的方法描述符包含了返回类型，因此 Java 虚拟机能够准确地识别目标方法。
 * </p>
 * <p>
 * 对重载方法的区分在编译阶段已经完成，我们可以认为 Java 虚拟机不存在重载这一概念。
 * 因此，在某些文章中，重载也被称为静态绑定（static binding），或者编译时多态（compile-time polymorphism）；
 * 而重写则被称为动态绑定（dynamic binding）。
 * 因为某个类中的重载方法可能被它的子类所重写，
 * 因此 Java 编译器会将所有对非私有实例方法的调用编译为需要动态绑定的类型。
 * 确切地说，Java 虚拟机中的静态绑定指的是在解析时便能够直接识别目标方法的情况，而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。
 * </p>
 * <p>
 * Java字节码中与调用相关的指令共有五种。
 * invokestatic：用于调用静态方法。
 * invokespecial：用于调用私有实例方法、构造器，以及使用super关键字调用父类的实例方法或构造器，和所实现接口的默认方法。
 * invokevirtual：用于调用非私有实例方法。
 * invokeinterface：用于调用接口方法。
 * invokedynamic：用于调用动态方法。
 * </p>
 */
public class MethodInvoke {
    public static void main(String[] args) {
        // 调用第二个invoke方法，由于String 是 Object 的子类，因此 Java 编译器会认为第二个方法更为贴切
        invoke(null, 1);
        // 调用第二个invoke方法
        invoke(null, 1, 2);
        // 只有手动绕开可变长参数的语法糖，才能调用第一个invoke方法
        invoke(null, new Object[]{1});
    }

    private static void invoke(Object obj, Object... args) {
        System.out.println("Object Object...");
    }

    private static void invoke(String s, Object obj, Object... args) {
        System.out.println("String Object Object...");
    }
}
